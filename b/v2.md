- all programming languages limited, there are always domains where it is
  necessary to switch to another language. There are reasons for this.
- A programming language is a language and it should offer generic abstractions.
- Current programming languages allow you to express any computation, but
  sometimes with significant runtime overhead. They allow you to express any
  abstraction using just functions, but with significant runtime overhead. Want
  to efficiently express any binary and any abstraction at compile time.
  Essentially want functions to generate binary.
- needed
	- syntactical abstractions
		- Fexprs allow syntactical abstraction but should only be used for that.
		  Logical abstraction should be implemented in functions.
	- all primitives available
		- abstraction over syntax shouldn't be necessary.
		- for every primitive, create a single underlying function that
		  implements the logic and any number of front-end primitives / fexprs /
		  functions that only wrap the original. This makes sure further
		  abstraction can always be expressed in terms of the logical function
		  while regular use can make use of syntactic sugar.
		- At the lowest level, this means being able to generate any instruction
		  for the processor. However, it is also needed at higher levels.
	- build abstractions bottom-up
		- top-down abstractions cause ugly / mismatched abstraction layers in
		  the middle which causes ugly semantics.
	- keep it simple and orthogonal
- possible implementation
	- By generating C code using Lisp
	- By generating assembly using Lisp

```
(defmacro (defun name params body)
  (quasiquote (def (unquote name)
      (fn (unquote params) (unquote body)))))
```

```
(devau (defun name params body) env
  (bind env name (mkfn params env body)))
```

\title{All Primitives Available}
\date{\today}
\author{Lars Jellema}
\maketitle

Due to Turing-completeness, programming languages allow you to express any
computation. However, most do not allow you to express any implementation, that
is, any resulting binary. Often the shapes of the binary code you can produce
are limited, to enable the compiler to reason about that code.
